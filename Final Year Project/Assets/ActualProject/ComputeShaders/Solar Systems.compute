#pragma kernel CSMain
#include "Assets/ActualProject/Utility.hlsl"
float solarSystemSwitchDist;
float3 playerPosition;

RWStructuredBuffer<ChunkIdentifier> _ChunksBuffer;
RWStructuredBuffer<int> _SolarSystemCount;
AppendStructuredBuffer<SolarSystem> _SolarSystems; 
AppendStructuredBuffer<Planet> _Planets;
float time;
float fadeDist;
float timeStep;

float minLuminosity;
float maxLuminosity;

float minRadius;
float maxRadius;

float minWavelength;
float maxWavelength;

float4 colours[6];

/*
https://www.teachastronomy.com/textbook/Properties-of-Stars/Stefan-Boltzmann-Law/
Stefan-Boltzmann law: Flux energy emitted from a surface (Wm-2) = sigma * T4 
Total luminosity of a blackbody emitter (ie, a star): L=4πR2 sigma * T4
1 =
sigma - Stefan-Boltzmann constant - 5.67 * 10^-8 Wm^(-2)K^(-4)
Tells us that radius of a star is proportional to the root of its luminosity and inversely proportional to the square of its temperature

http://hyperphysics.phy-astr.gsu.edu/hbase/wien.html
Wien's Displacement Law: Relates a star's surface temperature to its peak wavelength (the wavelength at which it emits the most energy - the colour 
of radiation that it emits most strongly. Formally:
lambdaPeak * T = 2.898 * 10 ^(-3) mk

//Chapter 14, page 278 introductory-astronomy-and-astrophysics_compress.pdf
//Population 1 stars are hot, young and blue. Inhabit the spiral arms.
//Population 2 stars are cool, red and blue. They inhabit the galactic halo and galactic disc.

Approach: initialise stars with a random luminosity and radius.
Compute the star's surface temperature using Stefan-Boltzmann
Compute lambdaPeak using Wien's Displacement Law
Generate an appropriate colour based on wavelength

//Chapter 13, page 258 introductory-astronomy-and-astrophysics_compress.pdf
https://astrobackyard.com/types-of-stars/
Main Sequence stars are classified into 1 of 7 groups using the Harvard Spectral classification.
For our calculations, we will consider sol as having a temperature, radius and luminosity of 100
Sol Temp, T = 5700k, Sol radius, R = 696,340 km, Sol luminosity, 100L = 3.846 * 10^26 W
O - 7.0T, 10R, 10000000L 
B -  3.5T, 5R, 100000L
A - 1.5T, 1.7R, 2000L
F - 1.14T, 1.3R, 400L
G - 1T, 1R, 100L
K - 0.79T, 0.7R, 20L
M - 0.56T, 0.2R, L

I want the peak wavelength to be returned in nanometres. This will make it easier to convert to colours as the visible range
of colours is 350 - 700 nm




*/

// Example compute shader function
[numthreads(8, 8, 8)]
void CSMain(uint3 id : SV_DispatchThreadID) {
    if(_SolarSystemCount[0] == 0) return;
    if(id.x >= _ChunksBuffer[0].chunksInViewDist || id.y >= _ChunksBuffer[0].chunksInViewDist || id.z >= _ChunksBuffer[0].chunksInViewDist) return;
    int currentChunkCoordX = round(playerPosition.x / float(_ChunksBuffer[0].chunkSize));
    int currentChunkCoordY = round(playerPosition.y / float(_ChunksBuffer[0].chunkSize));
    int currentChunkCoordZ = round(playerPosition.z / float(_ChunksBuffer[0].chunkSize));

    int curXOffset = -round(_ChunksBuffer[0].chunksInViewDist/2) + currentChunkCoordX + id.x; 
    int curYOffset = -round(_ChunksBuffer[0].chunksInViewDist/2) + currentChunkCoordY + id.y; 
    int curZOffset = -round(_ChunksBuffer[0].chunksInViewDist/2) + currentChunkCoordZ + id.z; 

    int3 viewedChunkCoord = int3(curXOffset, curYOffset, curZOffset);
    uint width;
    uint height;

    float3 actualPosition = viewedChunkCoord * _ChunksBuffer[0].chunkSize;
    float dist = length(actualPosition - playerPosition);
    float lodDist = solarSystemSwitchDist + fadeDist;
    if (dist < lodDist && _ChunksBuffer[0].chunkType == 2)
    {
        float random = Hash31(actualPosition);
        SolarSystem system = (SolarSystem)0;
        system.starPosition = actualPosition;
        system.starRadius = lerp(minRadius, maxRadius, random);
        system.starLuminosity = weightedRandomSample(random);
        system.starMass = calculateSphereMass(system.starRadius, 1.0);
        system.starColour = ColourFromLuminosity(system.starLuminosity, system.starRadius, colours[0], colours[1], colours[2], colours[3], colours[4], colours[5]);;
        system.planetCount = ceil(10 * random);
        system.fade = CrossFade(playerPosition, actualPosition, -1.0, lodDist, fadeDist);
        _SolarSystems.Append(system);
        float maxDist = 10.0;
        for(int i = 0; i < system.planetCount; i++)
        {
            float planetRandom = Hash1(float(i)/float(system.planetCount) * length(actualPosition));
            
            Planet planet = (Planet)0;
            float distFromStar = system.starRadius + maxDist * planetRandom;
            float initialAngle = (float(i)/float(system.planetCount)) * 2.0 * PI;
            float angle = initialAngle + CalculatePlanetAngularVelocity(distFromStar, system.starMass, 1.0) * time * timeStep;
            float x = distFromStar * cos(angle);
            float z = distFromStar * sin(angle);
            planet.position = actualPosition + float3(x, 0, z);
            planet.radius = lerp(0.1, 0.4, planetRandom);
            planet.mass = calculateSphereMass(planet.radius, 1.0);
            planet.colour = float4(0.8, 0.1, 0.4, 1.0);
            planet.rotationSpeed = 5.0 * time * timeStep;
            planet.rotationAxis = float3(0.0, 1.0, 0.0);

            _Planets.Append(planet);
        }

    }
}