#pragma kernel CSMain
#include "Assets/ActualProject/Utility.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Core.hlsl"
#include "Packages/com.unity.render-pipelines.universal/ShaderLibrary/Lighting.hlsl"

float lodSwitchDist;
float galaxyFadeDist;
float3 playerPosition;

float2 minMaxMinimumEccentricity;
float2 minMaxMaximumEccentricity;

float2 minMaxAngularOffsetMultiplier;

float2 minMaxHaloRadius;
float2 minMaxBulgeRadius;
float2 minMaxDiskRadius;

int2 minMaxNumParticles;

RWStructuredBuffer<ChunkIdentifier> _ChunksBuffer;
AppendStructuredBuffer<GalaxyProperties> _MainProperties;
AppendStructuredBuffer<MeshProperties> _Properties4;


[numthreads(8, 8, 8)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if(id.x >= _ChunksBuffer[0].chunksInViewDist || id.y >= _ChunksBuffer[0].chunksInViewDist || id.z >= _ChunksBuffer[0].chunksInViewDist) return;
    int currentChunkCoordX = round(playerPosition.x / float(_ChunksBuffer[0].chunkSize));
    int currentChunkCoordY = round(playerPosition.y / float(_ChunksBuffer[0].chunkSize));
    int currentChunkCoordZ = round(playerPosition.z / float(_ChunksBuffer[0].chunkSize));

    int curXOffset = -round(_ChunksBuffer[0].chunksInViewDist/2) + currentChunkCoordX + id.x; 
    int curYOffset = -round(_ChunksBuffer[0].chunksInViewDist/2) + currentChunkCoordY + id.y; 
    int curZOffset = -round(_ChunksBuffer[0].chunksInViewDist/2) + currentChunkCoordZ + id.z; 

    int3 viewedChunkCoord = int3(curXOffset, curYOffset, curZOffset);
    uint width;
    uint height;

    float3 actualPosition = viewedChunkCoord * _ChunksBuffer[0].chunkSize;
    float dist = length(actualPosition - playerPosition);


    float random = Hash31(actualPosition);
    float scale = lerp(minMaxHaloRadius.x, minMaxHaloRadius.y, random);
    float lodDist = lodSwitchDist * max(1.0, scale) + galaxyFadeDist;
    float fade = CrossFade(playerPosition, actualPosition, 10000.0, lodDist, galaxyFadeDist);
    float4 colour = lerp(float4(1.0, 0.0, 0.0, 1.0), float4(0.0, 0.0, 1.0, 1.0), random);
    float3 rotation = Hash33(actualPosition) * 2.0 * PI;
    MeshProperties mp = GenerateMeshProperties(actualPosition, rotation, scale, _ChunksBuffer[0].chunkType, colour, fade);

    float minEccentricity = lerp(minMaxMinimumEccentricity.x, minMaxMinimumEccentricity.y, random);
    float maxEccentricity = lerp(minMaxMaximumEccentricity.x, minMaxMaximumEccentricity.y, random);
    float haloRadius = scale;
    float bulgeRadius = lerp(minMaxBulgeRadius.x, minMaxBulgeRadius.y, random);
    float diskRadius = lerp(minMaxDiskRadius.x, minMaxDiskRadius.y, random);
    float angularOffsetMultiplier = lerp(minMaxAngularOffsetMultiplier.x, minMaxAngularOffsetMultiplier.y, random);
    int numParticles = lerp(minMaxNumParticles.x, minMaxNumParticles.y, random);
    GalaxyProperties gp = GenerateGalaxyProperties(mp, minEccentricity, maxEccentricity, haloRadius, bulgeRadius, diskRadius, angularOffsetMultiplier, numParticles);
    
    if (dist < lodDist && _ChunksBuffer[0].chunkType == 3)
    {
        _MainProperties.Append(gp);
    }

}

